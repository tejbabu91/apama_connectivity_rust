#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(unused_imports)]
#![allow(non_snake_case)]
/* automatically generated by rust-bindgen */

pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[doc = " Empty"]
pub const sag_data_tag_SAG_DATA_EMPTY: sag_data_tag = 0;
#[doc = " Bool"]
pub const sag_data_tag_SAG_DATA_BOOLEAN: sag_data_tag = 1;
#[doc = " 64-bit float"]
pub const sag_data_tag_SAG_DATA_DOUBLE: sag_data_tag = 2;
#[doc = " 64-bit signed int"]
pub const sag_data_tag_SAG_DATA_INTEGER: sag_data_tag = 3;
#[doc = " 64-bit IEEE-754 decimal"]
pub const sag_data_tag_SAG_DATA_DECIMAL: sag_data_tag = 4;
#[doc = " utf8-encoded const char*"]
pub const sag_data_tag_SAG_DATA_STRING: sag_data_tag = 5;
#[doc = " list of data"]
pub const sag_data_tag_SAG_DATA_LIST: sag_data_tag = 6;
#[doc = " map of data:data"]
pub const sag_data_tag_SAG_DATA_MAP: sag_data_tag = 7;
#[doc = " byte-array (8-bit signed int)"]
pub const sag_data_tag_SAG_DATA_BUFFER: sag_data_tag = 8;
#[doc = " a void* + deleter and copy function pointers"]
pub const sag_data_tag_SAG_DATA_CUSTOM: sag_data_tag = 9;
pub type sag_data_tag = u32;
#[doc = " A vector type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sag_underlying_vector_t {
    pub table: *mut sag_underlying_vector_table_t,
}
#[test]
fn bindgen_test_layout_sag_underlying_vector_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_vector_t>(),
        8usize,
        concat!("Size of: ", stringify!(sag_underlying_vector_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_vector_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_underlying_vector_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sag_underlying_vector_t>())).table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_vector_t),
            "::",
            stringify!(table)
        )
    );
}
#[doc = " A map type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sag_underlying_map_t {
    #[doc = " Table data"]
    pub table: *mut sag_underlying_map_table_t,
}
#[test]
fn bindgen_test_layout_sag_underlying_map_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_map_t>(),
        8usize,
        concat!("Size of: ", stringify!(sag_underlying_map_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_map_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_underlying_map_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sag_underlying_map_t>())).table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_map_t),
            "::",
            stringify!(table)
        )
    );
}
#[doc = " Byte buffers have a pointer to the buffer and a length"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sag_underlying_buffer_t {
    pub table: *mut sag_underlying_buffer_table_t,
}
#[test]
fn bindgen_test_layout_sag_underlying_buffer_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_buffer_t>(),
        8usize,
        concat!("Size of: ", stringify!(sag_underlying_buffer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_buffer_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_underlying_buffer_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sag_underlying_buffer_t>())).table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_buffer_t),
            "::",
            stringify!(table)
        )
    );
}
#[doc = " Custom data can be stored with function pointers to do deletion and"]
#[doc = "copying"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sag_underlying_custom_t {
    pub data: *mut sag_underlying_custom_data_t,
}
#[test]
fn bindgen_test_layout_sag_underlying_custom_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_custom_t>(),
        8usize,
        concat!("Size of: ", stringify!(sag_underlying_custom_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_custom_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_underlying_custom_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sag_underlying_custom_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_custom_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " A descriminated union type."]
#[doc = "See sag_data_tag for exact types of members."]
#[doc = "Only works in C11, GNU99 or C++ compilers."]
#[doc = "Should be 1 64-bit word plus the discriminator in size"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sag_underlying_data_t {
    pub __bindgen_anon_1: sag_underlying_data_t__bindgen_ty_1,
    #[doc = " The discriminator"]
    pub tag: sag_data_tag,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sag_underlying_data_t__bindgen_ty_1 {
    #[doc = " bool union member"]
    pub boolean: bool,
    #[doc = " integer union member"]
    pub integer: i64,
    #[doc = " floating point union member"]
    pub fp: f64,
    #[doc = " const char *union member"]
    pub string: *const ::std::os::raw::c_char,
    #[doc = " list union member"]
    pub list: sag_underlying_vector_t,
    #[doc = " map union member"]
    pub map: sag_underlying_map_t,
    #[doc = " custom pointer union member"]
    pub custom: sag_underlying_custom_t,
    #[doc = " byte buffer union member"]
    pub buffer: sag_underlying_buffer_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sag_underlying_data_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_data_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sag_underlying_data_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_data_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sag_underlying_data_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_data_t__bindgen_ty_1>())).boolean as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_data_t__bindgen_ty_1),
            "::",
            stringify!(boolean)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_data_t__bindgen_ty_1>())).integer as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_data_t__bindgen_ty_1),
            "::",
            stringify!(integer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_data_t__bindgen_ty_1>())).fp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_data_t__bindgen_ty_1),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_data_t__bindgen_ty_1>())).string as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_data_t__bindgen_ty_1),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_data_t__bindgen_ty_1>())).list as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_data_t__bindgen_ty_1),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_data_t__bindgen_ty_1>())).map as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_data_t__bindgen_ty_1),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_data_t__bindgen_ty_1>())).custom as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_data_t__bindgen_ty_1),
            "::",
            stringify!(custom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_data_t__bindgen_ty_1>())).buffer as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_data_t__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_sag_underlying_data_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_data_t>(),
        16usize,
        concat!("Size of: ", stringify!(sag_underlying_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_underlying_data_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sag_underlying_data_t>())).tag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_data_t),
            "::",
            stringify!(tag)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sag_underlying_vector_table_t {
    #[doc = " Number of items used in the vector"]
    pub count: u64,
    #[doc = " Capacity of the vector"]
    pub capacity: u64,
    #[doc = " vector data"]
    pub data: [sag_underlying_data_t; 1usize],
}
#[test]
fn bindgen_test_layout_sag_underlying_vector_table_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_vector_table_t>(),
        32usize,
        concat!("Size of: ", stringify!(sag_underlying_vector_table_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_vector_table_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_underlying_vector_table_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_vector_table_t>())).count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_vector_table_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_vector_table_t>())).capacity as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_vector_table_t),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_vector_table_t>())).data as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_vector_table_t),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sag_underlying_map_table_entry_t {
    pub hash: u64,
    pub key: sag_underlying_data_t,
    pub value: sag_underlying_data_t,
}
#[test]
fn bindgen_test_layout_sag_underlying_map_table_entry_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_map_table_entry_t>(),
        40usize,
        concat!("Size of: ", stringify!(sag_underlying_map_table_entry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_map_table_entry_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sag_underlying_map_table_entry_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_map_table_entry_t>())).hash as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_map_table_entry_t),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_map_table_entry_t>())).key as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_map_table_entry_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_map_table_entry_t>())).value as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_map_table_entry_t),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sag_underlying_map_table_t {
    #[doc = " Optional type name of contained data"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Number of valid items in the map table"]
    pub count: u64,
    #[doc = " Total capacity of the map table"]
    pub capacity: u64,
    #[doc = " Number of holes (deleted items) in the map table"]
    pub holes: u64,
    #[doc = " Table data"]
    pub table: [sag_underlying_map_table_entry_t; 1usize],
}
#[test]
fn bindgen_test_layout_sag_underlying_map_table_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_map_table_t>(),
        72usize,
        concat!("Size of: ", stringify!(sag_underlying_map_table_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_map_table_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_underlying_map_table_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sag_underlying_map_table_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_map_table_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_map_table_t>())).count as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_map_table_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_map_table_t>())).capacity as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_map_table_t),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_map_table_t>())).holes as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_map_table_t),
            "::",
            stringify!(holes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_map_table_t>())).table as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_map_table_t),
            "::",
            stringify!(table)
        )
    );
}
#[doc = " Underlying table type for buffers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sag_underlying_buffer_table_t {
    #[doc = " Length of buffer"]
    pub length: u64,
    #[doc = " buffer data"]
    pub data: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_sag_underlying_buffer_table_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_buffer_table_t>(),
        16usize,
        concat!("Size of: ", stringify!(sag_underlying_buffer_table_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_buffer_table_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_underlying_buffer_table_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_buffer_table_t>())).length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_buffer_table_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_buffer_table_t>())).data as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_buffer_table_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Underlying custom data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sag_underlying_custom_data_t {
    #[doc = " This is refcounted and shallow copied"]
    pub refcount: u64,
    #[doc = " Pointer to the underlying object"]
    pub custom: *mut ::std::os::raw::c_void,
    #[doc = " Function pointer to delete the underlying object"]
    pub deleter: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    #[doc = " Function pointer to copy the underlying object"]
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
    >,
}
#[test]
fn bindgen_test_layout_sag_underlying_custom_data_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_custom_data_t>(),
        32usize,
        concat!("Size of: ", stringify!(sag_underlying_custom_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_custom_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_underlying_custom_data_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_custom_data_t>())).refcount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_custom_data_t),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_custom_data_t>())).custom as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_custom_data_t),
            "::",
            stringify!(custom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_custom_data_t>())).deleter as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_custom_data_t),
            "::",
            stringify!(deleter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_custom_data_t>())).copy as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_custom_data_t),
            "::",
            stringify!(copy)
        )
    );
}
#[doc = " A message is a payload and a string/string map of metadata"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sag_underlying_message_t {
    #[doc = " Message payload"]
    pub payload: sag_underlying_data_t,
    #[doc = " Message metadata"]
    pub metadata: sag_underlying_map_t,
}
#[test]
fn bindgen_test_layout_sag_underlying_message_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_message_t>(),
        24usize,
        concat!("Size of: ", stringify!(sag_underlying_message_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_message_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_underlying_message_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_message_t>())).payload as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_message_t),
            "::",
            stringify!(payload)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_message_t>())).metadata as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_message_t),
            "::",
            stringify!(metadata)
        )
    );
}
#[doc = " A void* in a typed wrapper representing plugins"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sag_plugin_t {
    #[doc = " The plugin"]
    pub plugin: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sag_plugin_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_plugin_t>(),
        8usize,
        concat!("Size of: ", stringify!(sag_plugin_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_plugin_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_plugin_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sag_plugin_t>())).plugin as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_plugin_t),
            "::",
            stringify!(plugin)
        )
    );
}
#[doc = " A void* in a typed wrapper representing a status reporter item"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sag_status_item_t {
    #[doc = " The item"]
    pub item: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sag_status_item_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_status_item_t>(),
        8usize,
        concat!("Size of: ", stringify!(sag_status_item_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_status_item_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_status_item_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sag_status_item_t>())).item as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_status_item_t),
            "::",
            stringify!(item)
        )
    );
}
