#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(unused_imports)]
#![allow(non_snake_case)]
/* automatically generated by rust-bindgen */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const SAG_PLUGIN_API_VERSION: u32 = 4;
pub const SAG_PLUGIN_PRODUCT_VERSION: &'static [u8; 9usize] = b"10.5.3.0\0";
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " Empty"]
pub const sag_data_tag_SAG_DATA_EMPTY: sag_data_tag = 0;
#[doc = " Bool"]
pub const sag_data_tag_SAG_DATA_BOOLEAN: sag_data_tag = 1;
#[doc = " 64-bit float"]
pub const sag_data_tag_SAG_DATA_DOUBLE: sag_data_tag = 2;
#[doc = " 64-bit signed int"]
pub const sag_data_tag_SAG_DATA_INTEGER: sag_data_tag = 3;
#[doc = " 64-bit IEEE-754 decimal"]
pub const sag_data_tag_SAG_DATA_DECIMAL: sag_data_tag = 4;
#[doc = " utf8-encoded const char*"]
pub const sag_data_tag_SAG_DATA_STRING: sag_data_tag = 5;
#[doc = " list of data"]
pub const sag_data_tag_SAG_DATA_LIST: sag_data_tag = 6;
#[doc = " map of data:data"]
pub const sag_data_tag_SAG_DATA_MAP: sag_data_tag = 7;
#[doc = " byte-array (8-bit signed int)"]
pub const sag_data_tag_SAG_DATA_BUFFER: sag_data_tag = 8;
#[doc = " a void* + deleter and copy function pointers"]
pub const sag_data_tag_SAG_DATA_CUSTOM: sag_data_tag = 9;
#[doc = " \\private"]
#[doc = " Internal string optimization only for use by the correlator."]
pub const sag_data_tag_SAG_DATA_CONST_STRING: sag_data_tag = 10;
#[doc = " A descriminator for the content of the data_t union"]
pub type sag_data_tag = u32;
#[doc = " No error"]
pub const sag_error_t_SAG_ERROR_OK: sag_error_t = 0;
#[doc = " An exception was thrown"]
pub const sag_error_t_SAG_ERROR_EXCEPTION: sag_error_t = 1;
#[doc = " Other failure condition"]
pub const sag_error_t_SAG_ERROR_FAILED: sag_error_t = 2;
#[doc = " Unknown state"]
pub const sag_error_t_SAG_ERROR_UNKNOWN: sag_error_t = 3;
#[doc = " \\private"]
pub type sag_error_t = u32;
#[doc = " Critical log messages"]
pub const sag_log_level_t_SAG_LOG_CRIT: sag_log_level_t = 0;
#[doc = " Fatal errors"]
pub const sag_log_level_t_SAG_LOG_FATAL: sag_log_level_t = 1;
#[doc = " Non-fatal errors"]
pub const sag_log_level_t_SAG_LOG_ERROR: sag_log_level_t = 2;
#[doc = " Warnings"]
pub const sag_log_level_t_SAG_LOG_WARN: sag_log_level_t = 3;
#[doc = " Informational messages (default)"]
pub const sag_log_level_t_SAG_LOG_INFO: sag_log_level_t = 4;
#[doc = " Debug messages"]
pub const sag_log_level_t_SAG_LOG_DEBUG: sag_log_level_t = 5;
#[doc = " Trace"]
pub const sag_log_level_t_SAG_LOG_TRACE: sag_log_level_t = 6;
#[doc = " Log levels for logging to the host log file."]
pub type sag_log_level_t = u32;
#[doc = " Decimals are implemented with an underlying 64bit int conforming to IEEE"]
#[doc = "754 decimal 64. This struct only provides access to the 64 bit data, which can be accessed with a 64-bit decimal"]
#[doc = "library in order to perform arithmetic or convert to and from strings."]
#[doc = ""]
#[doc = "See also com::softwareag::connectivity::decimal_t which is how this should be referred to in customer code."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sag_underlying_decimal_t {
    #[doc = " The IEEE-754 data"]
    pub d: u64,
}
#[test]
fn bindgen_test_layout_sag_underlying_decimal_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_decimal_t>(),
        8usize,
        concat!("Size of: ", stringify!(sag_underlying_decimal_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_decimal_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_underlying_decimal_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sag_underlying_decimal_t>())).d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_decimal_t),
            "::",
            stringify!(d)
        )
    );
}
#[doc = " A vector type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sag_underlying_vector_t {
    pub table: *mut sag_underlying_vector_table_t,
}
#[test]
fn bindgen_test_layout_sag_underlying_vector_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_vector_t>(),
        8usize,
        concat!("Size of: ", stringify!(sag_underlying_vector_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_vector_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_underlying_vector_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sag_underlying_vector_t>())).table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_vector_t),
            "::",
            stringify!(table)
        )
    );
}
#[doc = " A map type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sag_underlying_map_t {
    #[doc = " Table data"]
    pub table: *mut sag_underlying_map_table_t,
}
#[test]
fn bindgen_test_layout_sag_underlying_map_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_map_t>(),
        8usize,
        concat!("Size of: ", stringify!(sag_underlying_map_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_map_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_underlying_map_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sag_underlying_map_t>())).table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_map_t),
            "::",
            stringify!(table)
        )
    );
}
#[doc = " Byte buffers have a pointer to the buffer and a length"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sag_underlying_buffer_t {
    pub table: *mut sag_underlying_buffer_table_t,
}
#[test]
fn bindgen_test_layout_sag_underlying_buffer_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_buffer_t>(),
        8usize,
        concat!("Size of: ", stringify!(sag_underlying_buffer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_buffer_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_underlying_buffer_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sag_underlying_buffer_t>())).table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_buffer_t),
            "::",
            stringify!(table)
        )
    );
}
#[doc = " Custom data can be stored with function pointers to do deletion and"]
#[doc = "copying"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sag_underlying_custom_t {
    pub data: *mut sag_underlying_custom_data_t,
}
#[test]
fn bindgen_test_layout_sag_underlying_custom_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_custom_t>(),
        8usize,
        concat!("Size of: ", stringify!(sag_underlying_custom_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_custom_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_underlying_custom_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sag_underlying_custom_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_custom_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " A descriminated union type."]
#[doc = "See sag_data_tag for exact types of members."]
#[doc = "Only works in C11, GNU99 or C++ compilers."]
#[doc = "Should be 1 64-bit word plus the discriminator in size"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sag_underlying_data_t {
    pub __bindgen_anon_1: sag_underlying_data_t__bindgen_ty_1,
    #[doc = " The discriminator"]
    pub tag: sag_data_tag,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sag_underlying_data_t__bindgen_ty_1 {
    #[doc = " bool union member"]
    pub boolean: bool,
    #[doc = " integer union member"]
    pub integer: i64,
    #[doc = " floating point union member"]
    pub fp: f64,
    #[doc = " const char *union member"]
    pub string: *const ::std::os::raw::c_char,
    #[doc = " decimal union member"]
    pub decimal: sag_underlying_decimal_t,
    #[doc = " list union member"]
    pub list: sag_underlying_vector_t,
    #[doc = " map union member"]
    pub map: sag_underlying_map_t,
    #[doc = " custom pointer union member"]
    pub custom: sag_underlying_custom_t,
    #[doc = " byte buffer union member"]
    pub buffer: sag_underlying_buffer_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sag_underlying_data_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_data_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sag_underlying_data_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_data_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sag_underlying_data_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_data_t__bindgen_ty_1>())).boolean as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_data_t__bindgen_ty_1),
            "::",
            stringify!(boolean)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_data_t__bindgen_ty_1>())).integer as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_data_t__bindgen_ty_1),
            "::",
            stringify!(integer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_data_t__bindgen_ty_1>())).fp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_data_t__bindgen_ty_1),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_data_t__bindgen_ty_1>())).string as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_data_t__bindgen_ty_1),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_data_t__bindgen_ty_1>())).decimal as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_data_t__bindgen_ty_1),
            "::",
            stringify!(decimal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_data_t__bindgen_ty_1>())).list as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_data_t__bindgen_ty_1),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_data_t__bindgen_ty_1>())).map as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_data_t__bindgen_ty_1),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_data_t__bindgen_ty_1>())).custom as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_data_t__bindgen_ty_1),
            "::",
            stringify!(custom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_data_t__bindgen_ty_1>())).buffer as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_data_t__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_sag_underlying_data_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_data_t>(),
        16usize,
        concat!("Size of: ", stringify!(sag_underlying_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_underlying_data_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sag_underlying_data_t>())).tag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_data_t),
            "::",
            stringify!(tag)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sag_underlying_vector_table_t {
    #[doc = " Number of items used in the vector"]
    pub count: u64,
    #[doc = " Capacity of the vector"]
    pub capacity: u64,
    #[doc = " vector data"]
    pub data: [sag_underlying_data_t; 1usize],
}
#[test]
fn bindgen_test_layout_sag_underlying_vector_table_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_vector_table_t>(),
        32usize,
        concat!("Size of: ", stringify!(sag_underlying_vector_table_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_vector_table_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_underlying_vector_table_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_vector_table_t>())).count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_vector_table_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_vector_table_t>())).capacity as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_vector_table_t),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_vector_table_t>())).data as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_vector_table_t),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sag_underlying_map_table_entry_t {
    pub hash: u64,
    pub key: sag_underlying_data_t,
    pub value: sag_underlying_data_t,
}
#[test]
fn bindgen_test_layout_sag_underlying_map_table_entry_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_map_table_entry_t>(),
        40usize,
        concat!("Size of: ", stringify!(sag_underlying_map_table_entry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_map_table_entry_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sag_underlying_map_table_entry_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_map_table_entry_t>())).hash as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_map_table_entry_t),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_map_table_entry_t>())).key as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_map_table_entry_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_map_table_entry_t>())).value as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_map_table_entry_t),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sag_underlying_map_table_t {
    #[doc = " Optional type name of contained data"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Number of valid items in the map table"]
    pub count: u64,
    #[doc = " Total capacity of the map table"]
    pub capacity: u64,
    #[doc = " Number of holes (deleted items) in the map table"]
    pub holes: u64,
    #[doc = " Table data"]
    pub table: [sag_underlying_map_table_entry_t; 1usize],
}
#[test]
fn bindgen_test_layout_sag_underlying_map_table_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_map_table_t>(),
        72usize,
        concat!("Size of: ", stringify!(sag_underlying_map_table_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_map_table_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_underlying_map_table_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sag_underlying_map_table_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_map_table_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_map_table_t>())).count as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_map_table_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_map_table_t>())).capacity as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_map_table_t),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_map_table_t>())).holes as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_map_table_t),
            "::",
            stringify!(holes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_map_table_t>())).table as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_map_table_t),
            "::",
            stringify!(table)
        )
    );
}
#[doc = " Underlying table type for buffers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sag_underlying_buffer_table_t {
    #[doc = " Length of buffer"]
    pub length: u64,
    #[doc = " buffer data"]
    pub data: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_sag_underlying_buffer_table_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_buffer_table_t>(),
        16usize,
        concat!("Size of: ", stringify!(sag_underlying_buffer_table_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_buffer_table_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_underlying_buffer_table_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_buffer_table_t>())).length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_buffer_table_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_buffer_table_t>())).data as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_buffer_table_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Underlying custom data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sag_underlying_custom_data_t {
    #[doc = " This is refcounted and shallow copied"]
    pub refcount: u64,
    #[doc = " Pointer to the underlying object"]
    pub custom: *mut ::std::os::raw::c_void,
    #[doc = " Function pointer to delete the underlying object"]
    pub deleter: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    #[doc = " Function pointer to copy the underlying object"]
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
    >,
}
#[test]
fn bindgen_test_layout_sag_underlying_custom_data_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_custom_data_t>(),
        32usize,
        concat!("Size of: ", stringify!(sag_underlying_custom_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_custom_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_underlying_custom_data_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_custom_data_t>())).refcount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_custom_data_t),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_custom_data_t>())).custom as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_custom_data_t),
            "::",
            stringify!(custom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_custom_data_t>())).deleter as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_custom_data_t),
            "::",
            stringify!(deleter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_custom_data_t>())).copy as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_custom_data_t),
            "::",
            stringify!(copy)
        )
    );
}
#[doc = " A message is a payload and a string/string map of metadata"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sag_underlying_message_t {
    #[doc = " Message payload"]
    pub payload: sag_underlying_data_t,
    #[doc = " Message metadata"]
    pub metadata: sag_underlying_map_t,
}
#[test]
fn bindgen_test_layout_sag_underlying_message_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_underlying_message_t>(),
        24usize,
        concat!("Size of: ", stringify!(sag_underlying_message_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_underlying_message_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_underlying_message_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_message_t>())).payload as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_message_t),
            "::",
            stringify!(payload)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sag_underlying_message_t>())).metadata as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_underlying_message_t),
            "::",
            stringify!(metadata)
        )
    );
}
#[doc = " A void* in a typed wrapper representing plugins"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sag_plugin_t {
    #[doc = " The plugin"]
    pub plugin: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sag_plugin_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_plugin_t>(),
        8usize,
        concat!("Size of: ", stringify!(sag_plugin_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_plugin_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_plugin_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sag_plugin_t>())).plugin as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_plugin_t),
            "::",
            stringify!(plugin)
        )
    );
}
#[doc = " A void* in a typed wrapper representing a status reporter item"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sag_status_item_t {
    #[doc = " The item"]
    pub item: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sag_status_item_t() {
    assert_eq!(
        ::std::mem::size_of::<sag_status_item_t>(),
        8usize,
        concat!("Size of: ", stringify!(sag_status_item_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sag_status_item_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sag_status_item_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sag_status_item_t>())).item as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sag_status_item_t),
            "::",
            stringify!(item)
        )
    );
}
extern "C" {
    #[doc = " Deep copy a data_t."]
    pub fn sag_copy_data(arg1: sag_underlying_data_t) -> sag_underlying_data_t;
}
extern "C" {
    #[doc = " Allocate a vector of (at least) the given size"]
    pub fn sag_allocate_vector(arg1: u64) -> sag_underlying_vector_t;
}
extern "C" {
    #[doc = " Allocate a new vector of (at least) the given size and shallow-copy the"]
    #[doc = "old vector into it, then free the old vector."]
    pub fn sag_reallocate_vector(
        arg1: sag_underlying_vector_t,
        arg2: u64,
    ) -> sag_underlying_vector_t;
}
extern "C" {
    #[doc = " Free the provided vector"]
    pub fn sag_free_vector(arg1: sag_underlying_vector_t);
}
extern "C" {
    #[doc = " Allocate a map of (at least) the given size"]
    pub fn sag_allocate_map(arg1: u64) -> sag_underlying_map_t;
}
extern "C" {
    #[doc = " Allocate a new map of (at least) the given size and shallow-copy the old"]
    #[doc = "map into it, then free the old map"]
    pub fn sag_reallocate_map(arg1: sag_underlying_map_t, arg2: u64) -> sag_underlying_map_t;
}
extern "C" {
    #[doc = " Free the given map"]
    pub fn sag_free_map(arg1: sag_underlying_map_t);
}
extern "C" {
    #[doc = " Copy the given string"]
    pub fn sag_copy_string(arg1: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Copy the given string, but only the first n bytes"]
    pub fn sag_copy_partial_string(
        arg1: *const ::std::os::raw::c_char,
        arg2: i64,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the hash of the given string"]
    pub fn sag_hash_string(arg1: *const ::std::os::raw::c_char) -> u64;
}
extern "C" {
    #[doc = " Free the given string, parameter must be value returned from sag_copy_string"]
    pub fn sag_free_string(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Allocate a byte buffer"]
    pub fn sag_allocate_buffer(arg1: u64) -> sag_underlying_buffer_t;
}
extern "C" {
    #[doc = " Free a byte buffer"]
    pub fn sag_free_buffer(arg1: sag_underlying_buffer_t);
}
extern "C" {
    #[doc = " Copy a byte buffer"]
    pub fn sag_copy_buffer(arg1: sag_underlying_buffer_t) -> sag_underlying_buffer_t;
}
extern "C" {
    #[doc = " Allocate a custom"]
    pub fn sag_allocate_custom(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
    ) -> sag_underlying_custom_t;
}
extern "C" {
    #[doc = " Free a custom"]
    pub fn sag_free_custom(arg1: sag_underlying_custom_t);
}
extern "C" {
    #[doc = " Copy a custom"]
    pub fn sag_copy_custom(arg1: sag_underlying_custom_t, shallow: bool)
        -> sag_underlying_custom_t;
}
extern "C" {
    #[doc = " Log a message to the system log file at the given level"]
    pub fn sag_log_at(
        arg1: *const ::std::os::raw::c_char,
        arg2: sag_log_level_t,
        arg3: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Returns the current log level for the given category"]
    pub fn sag_get_log_level(arg1: *const ::std::os::raw::c_char) -> sag_log_level_t;
}
extern "C" {
    #[doc = " Create a chain"]
    pub fn sag_create_chain(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: sag_underlying_vector_t,
        arg6: sag_underlying_vector_t,
        arg7: sag_underlying_map_t,
        arg8: *mut ::std::os::raw::c_void,
    ) -> sag_plugin_t;
}
extern "C" {
    #[doc = " Start a created chain"]
    pub fn sag_start_chain(arg1: *mut ::std::os::raw::c_void, arg2: sag_plugin_t) -> sag_error_t;
}
extern "C" {
    #[doc = " Destroy a chain"]
    pub fn sag_destroy_chain(arg1: *mut ::std::os::raw::c_void, arg2: sag_plugin_t) -> sag_error_t;
}
extern "C" {
    #[doc = " Create a user-defined status value"]
    pub fn sag_create_user_status_item(
        connectivityManager: *mut ::std::os::raw::c_void,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> sag_status_item_t;
}
extern "C" {
    #[doc = " Delete a user-defined status value"]
    pub fn sag_delete_user_status_item(
        connectivityManager: *mut ::std::os::raw::c_void,
        arg1: sag_status_item_t,
    );
}
extern "C" {
    #[doc = " Set the current value of a user-defined status value"]
    pub fn sag_set_user_status_item(arg1: sag_status_item_t, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set user-defined status values from a string,string map"]
    pub fn sag_set_user_status_map(
        arg1: *mut ::std::os::raw::c_void,
        arg2: sag_underlying_map_t,
    ) -> sag_error_t;
}
extern "C" {
    #[doc = " Enable reliability"]
    pub fn sag_enable_reliability(
        chain: *mut ::std::os::raw::c_void,
        direction: ::std::os::raw::c_int,
    ) -> sag_error_t;
}
extern "C" {
    #[doc = " Set the thread cache on this thread"]
    pub fn sag_set_thread_cache(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " destroy a thread cache"]
    pub fn sag_destroy_thread_cache(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " create a thread cache"]
    pub fn sag_create_thread_cache() -> *mut ::std::os::raw::c_void;
}
#[doc = " Fn pointer type for send batch functions"]
pub type sag_send_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: sag_plugin_t,
        arg2: *mut sag_underlying_message_t,
        arg3: *mut sag_underlying_message_t,
    ) -> sag_error_t,
>;
#[doc = " Fn pointer type for create plugin functions, considered legacy from 9.12.0.1 onwards (we retain this only to preserve binary compat between 9.12.0.0 and 9.12.0.1)"]
pub type sag_create_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: sag_underlying_data_t,
    ) -> sag_plugin_t,
>;
#[doc = " Fn pointer type for create plugin functions, available from 9.12.0.1 onwards"]
pub type sag_create_with_params_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: sag_underlying_data_t,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut ::std::os::raw::c_void,
    ) -> sag_plugin_t,
>;
#[doc = " Fn pointer type for sag_chainmanager_create functions"]
pub type sag_chainmanager_create_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        config: sag_underlying_data_t,
        managerName: *const ::std::os::raw::c_char,
        transportPluginName: *const ::std::os::raw::c_char,
        connectivityManager: *mut ::std::os::raw::c_void,
        chainDefs: sag_underlying_data_t,
        reserved: *mut ::std::os::raw::c_void,
    ) -> sag_plugin_t,
>;
#[doc = " Fn pointer type for chainmanager_createTransport function"]
pub type sag_chainmanager_createTransport_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        managerplugin: sag_plugin_t,
        chainId: *const ::std::os::raw::c_char,
        config: sag_underlying_data_t,
        connectivityManager: *mut ::std::os::raw::c_void,
        defaultChannelTowardsHost: *const ::std::os::raw::c_char,
        subscribeChannels: sag_underlying_vector_t,
        createFun: *mut ::std::os::raw::c_void,
        reserved: *mut ::std::os::raw::c_void,
    ) -> sag_plugin_t,
>;
#[doc = " Fn pointer type for start, shutdown, hostReady and destroy functions"]
pub type sag_status_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: sag_plugin_t) -> sag_error_t>;
#[doc = " Fn pointer type for setNext functions"]
pub type sag_set_next_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: sag_plugin_t,
        arg2: sag_plugin_t,
        arg3: sag_send_fn_t,
    ) -> sag_error_t,
>;
#[doc = " Fn pointer type for api_version functions"]
pub type sag_version_fn_t = ::std::option::Option<unsafe extern "C" fn() -> u64>;
#[doc = " Fn pointer type for returning the (static string constant) for the 4-digit product version number"]
pub type sag_product_version_fn_t =
    ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_char>;
#[doc = " Fn pointer type for channel listener callbacks"]
pub type sag_channel_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        listener: sag_plugin_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: bool,
    ) -> sag_error_t,
>;
extern "C" {
    #[doc = " Add a listener for channels"]
    pub fn sag_add_channel_listener(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
        arg3: sag_plugin_t,
        arg4: *const ::std::os::raw::c_char,
        arg5: sag_status_fn_t,
        arg6: sag_channel_fn_t,
        arg7: sag_channel_fn_t,
    ) -> sag_error_t;
}
extern "C" {
    pub fn sag_data_to_string(data: sag_underlying_data_t) -> sag_underlying_data_t;
}
